[//]: # (title: Artifact Dependencies)
[//]: # (auxiliary-id: Artifact Dependencies)

This page details configuration of the TeamCity _[artifact dependencies](dependent-build.md#Artifact+Dependency)_ that allow you to pass files from one build to another. For example, a typical [](deployment-build-configuration.md) publishes files generated by other (production) configurations.

Artifacts can be passed from:

* Configurations running before the target configuration within the same [](build-chain.md).

* Separate configurations that are not parts of the same build chain with the target configuration.

* Previous builds of the same configuration.

> TeamCity [automatically frees disk space](free-disk-space.md#artifacts-automatic-space) for resolving artifact dependencies based on the artifacts' size. You don't need to configure it manually.
> 
{style="tip"}

## Configuring Artifact Dependencies Using Web UI

To add an artifact dependency to a build configuration:

1. When [editing a build configuration](creating-and-editing-build-configurations.md), open the __Dependencies__ page.

    <img src="dk-add-artifact-dependency.png" width="706" alt="Add artifact dependency"/>

2. Click __Add new artifact dependency__ and specify the following settings:

    <img src="dk-artifact-dependency-dialog.png" width="706" alt="Add artifact dependency dialog"/>

    * **Depend on** — the build configuration for the current build configuration to depend on.
    
    <anchor id="artifact-dep-get-from" auxiliary-id="artifact-dep-get-from"/>
  
    * **Get artifacts from** — the type of build whose artifacts are to be taken:
  
        * Latest successful build — artifacts will be taken from the successful dependency build with the most recent revision (the latest change ID)
        * Latest [pinned build](build-actions.md#Pin+Build) — artifacts will be taken from the pinned dependency build with the most recent revision (the latest change ID)
        * Latest finished build: if a snapshot dependency is also configured in a build configuration, artifacts will be taken from the build with the same sources as the current build
        * Build from the same chain — this option is useful when you have a [snapshot dependency](snapshot-dependencies.md) and want to obtain artifacts from a build with the same sources
        * Build with specified build number
        * Latest finished build with specified tag
        
        > When selecting the build configuration, take your [clean-up policy settings](teamcity-data-clean-up.md) into account.
        > Builds are cleaned and deleted on a regular basis, thus the build configuration could become dependent on a non-existent build. When artifacts are taken from a build with a specific number, then the specific build will not be deleted during clean-up.
        > 
        {style="note"}

    * **Build number** — the exact [build number](configuring-general-settings.md#Build+Number+Format) of the artifact. This field is available if you have selected build with specific build number in the_ __Get artifacts from__ list.   

    * **Build tag** — the tag of the build whose artifacts are to be used. When resolving the dependency, TeamCity will look for the last successful build with the given tag and use its artifacts. This field appears if you have selected last finished build with specified tag in the __Get artifacts from__ list.

    * **Build branch filter** — allows setting a [branch filter](branch-filter.md) to limit source builds only to those in the matching branches. If not specified, the default branch is used. This field appears if the dependency has a [branch specified](working-with-feature-branches.md#Configuring+Branches) in the VCS root settings.

    * **Artifacts Rules** — string expressions that specify which files and folders should be downloaded, and where they should be stored. See this section for more information: [](#Artifacts+Rules).

    * **Clean destination paths before downloading artifacts** — check this option to delete the content of the destination directories before copying artifacts. It will be applied to all inclusive rules.

3. Click **Save** to add your new dependency.

At any point you can launch a build with [custom artifact dependencies](running-custom-build.md#Promoting+Build).

## Artifacts Rules

An artifact rule specifies which artifacts of the source build should be downloaded and where on the agent storage they should be stored.


>Watch our **video guide** on how to [work with artifact rules](https://www.youtube.com/watch?v=AXITbn7bNyA).

Each individual artifact rule should start from a new line and have the following syntax:

```
[+:|-:|?:]SourcePath[!ArchivePath][=>DestinationPath]
```

The order of a rules is irrelevant. For each artifact the most specific rule (the one with the longest prefix before the first wildcard symbol) is applied.

> Click the ![ArtifactsBrowserIcon.png](ArtifactsBrowserIcon.png) icon to invoke the Artifact Browser. TeamCity will try to locate artifacts according to the specified settings and show them in a tree. Select the required artifacts from the tree and TeamCity will place the paths to them into the input field.
>
{style="tip"}

### Prefix

* The `+:` prefix specifies a mandatory inclusive artifact dependency. This is the default prefix, meaning that all rules without prefixes are treated as inclusive (the `+:mylib.dll` and `mylib.dll` rules are identical).

* The `-:` prefix allows you to exclude a specific file from the download or unpacking. For example, if directory you wish to pass as an artifact dependency includes a few irrelevant for a build files, you may either go over all required files and include them using the `+:directory/file` syntax, or add the entire directory (`+:directory`) and exclude a few ignored files (`-:directory/junkfile`).

* The `?:` prefix allows you to create optional inclusive dependencies. If a build cannot obtain an artifact referenced in the `+:...` rule, this build fails with the "Failed to resolve artifact dependency" message. The `?:...` rule allows you to run a dependent build anyway (with a warning that the required artifact was not found printed in the build log). You can use the `?:` prefix to label as optional both standalone files (`?:/myfile.txt`) and files from [archives](#Archive+Path) (`?:dist.zip!myfile.txt `). See the following example for more information: [](#Optional+dependency).



### Source Path

The _SourcePath_ should be relative to the artifacts' directory of the "source" build. The path can either identify a specific file, directory, or use wildcards to match multiple files. [Ant-like wildcards](wildcards.md) are supported.   

Downloaded artifacts will keep the "source" directory structure starting with the first `*` or `?` wildcard.

### Archive Path

_ArchivePath_ is used to extract downloaded [compressed](configuring-general-settings.md#Artifact+Paths) artifacts. `zip`, `7zip`, `jar`, `tar`, and `tar.gz` are supported.   

_ArchivePath_ follows general rules for _SourcePath_: ant-like wildcards are allowed, the files matched inside the archive will be placed in the directory corresponding to the first wildcard match (relative to destination path). For example, the `release.zip!*.dll` rule will extract all .dll files residing in the root of the `release.zip` artifact.

### Destination Path

_DestinationPath_ specifies the destination directory on the agent where downloaded artifacts are to be placed. If the path is relative (which is recommended), it will be resolved against the build checkout directory. If needed, the destination directories can be cleaned before downloading artifacts. If the destination path is empty, artifacts will be downloaded directly to the checkout root.

Destination paths are ignored for exclusive (starting with the `-:` prefix) rules.

### Examples

#### Download all files from the target directory

To copy all files of from the target `a/b` directory of the source build to the `lib` directory of a dependent build, add the `a/b/**=>lib` rule. Copied files preserve their source hierarchy. For example, the `a/b/c/file.txt` file hosted in a sub-directory will be placed into the `lib/c/file.txt` folder.

#### Download all files that match the pattern

Wildcards allow you to specify patterns and that match multiple files as once. For example, the `**/*.txt=>lib` rule downloads all text files to the agent's `lib` directory.

Note that rules preserve the original directories structure. For example, the `a/b/c/file.txt` file will be stored as `lib/a/b/c/file.txt`.


#### Extract files from an archive

The [](#Archive+Path) portion of an artifact rule allows you to specify which files from the target archive the dependent build should download.

* The `a.zip!**=>destination` rule unpacks the entire archive to the `destination` library. The archive is unpacked as is, with the inner hierarchy of subfolders preserved.

* The `release-*.zip!*.dll=>dlls` rule extracts `*.dll` libraries from all archives matching the `release-*.zip` pattern, and saves these libraries to the `dlls` directory.

* The `a.zip!a/b/c/**/*.dll=>dlls` rule extracts all `.dll` files from `a/b/c` and its subdirectories into the `dlls` directory. Files matching this rule will be stored without the `a/b/c` path.


#### Exclude irrelevant files

Start an artifact rule with the `-:` prefix to tell TeamCity a file or files that matches this pattern should not be downloaded by the dependent build.

* Two following rules result in downloading all text files from all directories, apart from the `exclude.txt` file located in the `bad` directory. Downloaded files are saved to the `texts` folder.

  ```
  **/*.txt=>texts
  -:bad/exclude.txt
  ```


* The following set of rules finds all archives that start with `release`, unpacks its `.dll` libraries, and saves them to the `dlls` directory. The `Bad.dll` file from the `release-0.0.1.zip` archive is skipped.

  ```
  +:release-*.zip!**/*.dll=>dlls
  -:release-0.0.1.zip!Bad.dll
  ```

* The combination below results in dowloading all artifacts to the `target` directory. The dependent build will completely ignore the `excl` directory except for the `excl/must_have.txt` file.

  ```
  **/*.*=>target 
  -:excl/**/*.*
  +:excl/must_have.txt=>target
  ```

#### Download hidden artifacts

The artifacts placed under the `.teamcity` directory are considered [hidden](build-artifact.md#Hidden+Artifacts). These artifacts are ignored by wildcards by default.   
If you want to include files from the `.teamcity` directory for any purpose, be sure to add the artifact path starting with `.teamcity` explicitly, for example:

* `.teamcity/properties/*.properties`
* `.teamcity/*.*`

#### Optional dependency

The following [](kotlin-dsl.md) code illustrates a configuration that produces the `output.txt` artifact file.

```Kotlin
import jetbrains.buildServer.configs.kotlin.*
import jetbrains.buildServer.configs.kotlin.buildSteps.script

object ConfigA : BuildType({
    name = "ConfigA"
    artifactRules = "+:output.txt"
    steps {
        script {
            id = "simpleRunner"
            scriptContent = """
                touch output.txt
                echo "Config A running..." > output.txt
            """.trimIndent()
        }
    }
})
```

The dependent build configuration uses this `output.txt` file in its own script. However, the `if ... else` statement of the script allows for an alternative course of actions in case the target file is missing.


```Kotlin
import jetbrains.buildServer.configs.kotlin.*
import jetbrains.buildServer.configs.kotlin.buildSteps.script

object ConfigB : BuildType({
    name = "ConfigB"
    vcs {
        cleanCheckout = true
    }
    steps {
        script {
            id = "simpleRunner"
            scriptContent = """
                FILE=output.txt   
                
                if [ ! -f ${'$'}FILE ]
                then
                  echo "No source file exists"
                else cat ${'$'}FILE
                fi
            """.trimIndent()
        }
    }

    dependencies {
        dependency(ConfigA) {
            snapshot {
                reuseBuilds = ReuseBuilds.NO
            }
            artifacts {
                artifactRules = "?:output.txt"
            }
        }
    }
})
```

The `?:output.txt` dependency ensures the dependent build can start even if the target file was not found. If this happens, the build log will include a corresponding warning.

<img src="dk-relativeBuild-failed.png" width="706" alt="Optional dependency warning"/>



## Downloading Artifacts to Agent Home Directory

By default, artifacts can be dowloaded only to the [agent work directory](agent-work-directory.md), downloading to the [agent home directory](agent-home-directory.md) is prohibited. To override the defaults, set custom rules to download artifacts by specifying the comma-separated paths in the [`buildAgent.properties`](configure-agent-installation.md): `teamcity.artifactDependenciesResolution.bannedList` and `teamcity.artifactDependenciesResolution.allowedList`. Adding a path to the banned list forbids artifacts download to this directory unless it is present in the allowed list.



## Configuring Artifact Dependencies Using Ant Build Script

This section describes how to download TeamCity build artifacts inside the build script. These instructions can also be used to download artifacts from outside of TeamCity.

To handle artifact dependencies between builds, this solution is more complicated than configuring dependencies in the TeamCity UI but allows for greater flexibility. For example, managing dependencies this way will allow you to start a personal build and verify that your build is still compatible with dependencies.

To configure dependencies via Ant build script:

1\. Download Ivy.

<tip>

TeamCity itself acts as an Ivy repository. You can read more about the Ivy dependency manager [here](https://ant.apache.org/ivy/).
</tip>

2\. Add Ivy to the classpath of your build.

3\. Create the `ivyconf.xml` file that contains some meta information about TeamCity repository. This file is to have the following content:


```XML

<ivysettings>
<property name='ivy.checksums' value=''/>
<caches defaultCache="${teamcity.build.tempDir}/.ivy/cache"/>
<statuses>
    <status name='integration' integration='true'/>
</statuses>
<resolvers>
    <url name='teamcity-rep' alwaysCheckExactRevision='yes' checkmodified='true'>
        <ivy pattern='http://YOUR_TEAMCITY_HOST_NAME/httpAuth/repository/download/[module]/[revision]/teamcity-ivy.xml' />
        <artifact pattern='http://YOUR_TEAMCITY_HOST_NAME/httpAuth/repository/download/[module]/[revision]/[artifact](.[ext])' />
    </url>
</resolvers>
<modules>
    <module organisation='.*' name='.*' matcher='regexp' resolver='teamcity-rep' />
</modules>
</ivysettings>

```
4\. Replace `YOUR_TEAMCITY_HOST_NAME` with the host name of your TeamCity server.

5\. Place `ivyconf.xml` in the directory where your `build.xml` will be running.

6\. In the same directory create the `ivy.xml` file defining which artifacts to download and where to put them, for example:


```XML
<ivy-module version="1.3">
  <info organisation="YOUR_ORGANIZATION" module="YOUR_MODULE"/>
  <dependencies>
    <dependency org="org" name="BUILD_TYPE_EXT_ID" rev="BUILD_REVISION">
      <include name="ARTIFACT_FILE_NAME_WITHOUT_EXTENSION" ext="ARTIFACT_FILE_NAME_EXTENSION" matcher="exactOrRegexp"/>
    </dependency>
  </dependencies>
</ivy-module>

```

where:
* `YOUR_ORGANIZATION` replace with the name of your organization.
* `YOUR_MODULE` replace with the name of your project or module where artifacts will be used.
* `BUILD_TYPE_EXT_ID` replace with the [external ID](changing-build-configuration-status.md#Status+Display+for+Set+of+Build+Configurations) of the build configuration whose artifacts are downloaded.
* `BUILD_REVISION` can be either a build number or one of the following strings: `* latest.lastFinished`
  * `latest.lastSuccessful`
  * `latest.lastPinned`
* `TAG_NAME.tcbuildtag` - last build tagged with the TAG_NAME tag


[//]: # (Internal note. Do not delete. "Artifact Dependenciesd15e580.txt")    

* `ARTIFACT_FILE_NAME_WITHOUT_EXTENSION` filename or regular expression of the artifact without the extension part.
* `ARTIFACT_FILE_NAME_EXTENSION` the extension part of the artifact filename.

7\. Modify your `build.xml` file and add tasks for downloading artifacts, for example (applicable for Ant 1.6 and later):

```XML
<target name="fetchArtifacts" description="Retrieves artifacts for TeamCity" xmlns:ivy="antlib:org.apache.ivy.ant">
 <taskdef uri="antlib:org.apache.ivy.ant"  resource="org/apache/ivy/ant/antlib.xml"/>
   <classpath>
     <pathelement location="${basedir}/lib/ivy-2.0.jar"/>
     <pathelement location="${basedir}/lib/commons-httpclient-3.0.1.jar"/>
     <pathelement location="${basedir}/lib/commons-logging.jar"/>
     <pathelement location="${basedir}/lib/commons-codec-1.3.jar"/>
   </classpath>
 </taskdef>
 <ivy:configure file="${basedir}/ivyconf.xml" />
 <!--<ivy:cleancache />-->
 <ivy:retrieve pattern="${basedir}/[artifact].[ext]"/>
</target>
```

> * `commons-httpclient`, `commons-logging`, and `commons-codec` are to be in the `classpath` of Ivy tasks.
> * To clean the Ivy cache directory before retrieving dependencies, uncomment the `<ivy:cleancache />` element in the example above.
>
{style="note"}

Artifacts repository is protected by a basic authentication. To access the artifacts, you need to provide credentials to the &lt;ivy:configure/&gt; task. For example:

```XML
<ivy:configure file="${basedir}/ivyconf.xml"
                 host="TEAMCITY_HOST"
                 realm="TeamCity"
                 username="USER_ID"
                 passwd="PASSWORD"/>

```

where `TEAMCITY_HOST` is hostname or IP address of your TeamCity server (without port and servlet context).   
As `USER_ID/PASSWORD` you can use either username/password of a regular TeamCity user (the user should have corresponding permissions to access artifacts of the source build configuration) or system properties `teamcity.auth.userId/teamcity.auth.password`.

## Build-level authentication

The system properties `teamcity.auth.userId` and `teamcity.auth.password` store automatically generated build-unique values which can be used to authenticate on TeamCity server. The values are valid only during the time the build is running. This generated user has limited permissions which allow build-related operations. The primary intent for the user is to use the authentication to download artifacts from other TeamCity builds within the build script.

Using the properties is preferable to using real user credentials since it allows the server to track the artifacts downloaded by your build. If the artifacts were downloaded by the build configuration artifact dependencies or using the supplied properties, the specific artifacts used by the build will be displayed at the __Dependencies__ tab on the __Build Results__ page. In addition, the builds which were used to get the artifacts from, can be configured to have different [clean-up](teamcity-data-clean-up.md) logic.



<seealso>
        <category ref="concepts">
            <a href="dependent-build.md">Dependent Build</a>
        </category>
</seealso>
