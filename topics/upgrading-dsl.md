[//]: # (title: Upgrading DSL)
[//]: # (auxiliary-id: Upgrading DSL)

The TeamCity XML settings format is usually [changed](storing-project-settings-in-version-control.md#Enabling+Versioned+Settings+after+TeamCity+Upgrade) in the major releases.   
During the first start after the server update, TeamCity converts XML settings files in the TeamCity Data Directory to the new format.      
When settings are stored in Kotlin DSL, the Kotlin code might need to be changed to be still functional. It is also recommended to update the Kotlin code to the latest [DSL API version](#dslAPIVersion) and [config version](#configsVersion).
         
These recommendations are displayed as server health reports on the corresponding pages of the server administration UI.

## TeamCity settings format changes

As far as the DSL is concerned, there are the following types of TeamCity settings changes.

### Changes which can be performed automatically

These types of settings changes do not require changing the Kotlin DSL as the changes are applied by the server automatically on each settings regeneration from the DSL.   
It is recommended though to update the DSL to a newer configs version to reduce performance hit and make Kotlin scripts closer to the settings you see in the UI.

A lot of changes in TeamCity settings fall into this category. For example, some plugin implementing a build step may rename its parameters.   
The DSL from the previous TeamCity version generates a parameter with the old name, but TeamCity can automatically replace the old parameter name with the new one after DSL execution.

### Changes which cannot be performed automatically

Some TeamCity settings changes require external information and cannot be performed automatically. For example, in TeamCity 10.0 the settings of the cloud integration were stored in a dedicated file which was not committed to a VCS.

In TeamCity 2017.1, these settings were moved to the project level. TeamCity cannot perform such a transformation of settings automatically without external data,so manual DSL code update is required.

## Versions in DSL code

<anchor name="dslAPIVersion"/>

### Kotlin DSL API version

The DSL API version is encoded into the package name, for example: `jetbrains.buildServer.configs.kotlin.v2019_2`. The version part there corresponds to TeamCity version when this DSL API was introduced.

The new DSL API version is usually introduced when there are significant incompatible changes in DSL API.

TeamCity preserves backward compatibility, so if you started working with Kotlin DSL in TeamCity 2017.2, you can continue using classes from the `jetbrains.buildServer.configs.kotlin.v2017_2` package even in TeamCity 2019.2. 

<anchor name="configsVersion"/>

### Configs version

This is the version specified in `settings.kts`, it looks like this:

```kotlin
version = "2019.2"
```

TeamCity uses this version to perform transformations after DSL execution to make resulting XML configuration files up-to-date with the current TeamCity version where they will be applied. For instance, your DSL scripts could be generated by TeamCity 2017.2 and have the version set to `2017.2`. When you upgrade your server to version 2019.2, TeamCity will execute your DSL and apply additional transformations to modify the settings according to the format expected by version 2019.2.

## Enabling versioned settings after the upgrade

After a TeamCity upgrade, the versioned settings are disabled globally on the whole TeamCity server, and a corresponding health report is shown in the administration UI. This is done to prevent TeamCity from changing the settings in the version control if you upgrade a non-production copy of the TeamCity server.

If the server is a production installation, enable versioned settings using the action in the health report. This will make TeamCity commit converted XML configuration files to the VCS. If there were any changes to projects configuration via the web interface while versioned settings were disabled, these changes will be committed to the VCS repository too when settings are enabled.

## Kotlin DSL upgrade procedure

Usually, after the server upgrade, the Kotlin DSL scripts do not require any immediate changes and should produce the same result in the new TeamCity version. However, it is recommended to update the Kotlin DSL scripts to use the most recent [DSL API version](#dslAPIVersion) and [configs version](#configsVersion).

The upgrade procedure involves two steps:
1. Change all imports in the DSL scripts to the new DSL API package. For instance, imports like:   
     ```kotlin
     import jetbrains.buildServer.configs.kotlin.v2018_1.*
     import jetbrains.buildServer.configs.kotlin.v2018_1.projectFeatures.*
     ```
     should be changed to:
     ```kotlin
     import jetbrains.buildServer.configs.kotlin.v2019_2.*
     import jetbrains.buildServer.configs.kotlin.v2019_2.projectFeatures.*
     ```
     Usually this can be done with the help of search-and-replace in all import statements. After that, and after fixing all the compilation errors which may occur after this change, the modified Kotlin files can be committed and DSL should continue working as before.

2. Change _configs version_ to the most recent one, for instance, if your DSL scripts were generated by TeamCity 2018.1, your `settings.kts` contains:
     ```kotlin
     version = "2018.1"
     ```
     To change it to `2019.2`, you should first review the health reports produced by your TeamCity server after it applied the most recent changes in your DSL scripts. These health reports describe what should be changed in your scripts so no additional transformations are required and you could safely change _configs version_.   
    
     If you see a message like:
     ```text
      Please change the configs version to "2019.2" in projects:
      <the list of projects> 
     ```
    
     then no additional changes to your DSL are required and you can change the config's `version` to `2019.2`. Otherwise, you will receive the following message:
     
     ```text
     DSL scripts should be updated to produce settings for version 2019.2:
     change DSL for build configurations:
     <affected build configurations>
     to update DSL, do the following:
     <description of what should be changed>
     ```
    
     You should review these suggestions and apply them to your DSL scripts. The _configs version_ can be changed only after all these suggestions are applied.
    
    <note>
Instead of upgrading manually, you can always regenerate all of your Kotlin DSL scripts for your projects, unless you did not change them in the VCS repository since versioned settings were enabled in your project. To do this, you can disable and enable versioned settings again, and select the "_Overwrite_" option in the confirmation dialog. After that, TeamCity will make a commit to your VCS repository removing all previously generated Kotlin files and adding newly generated files corresponding to the current TeamCity version.
    </note>

<anchor name="dsl20192"/>

## Update DSL from 2019.1.x to 2019.2.x

* The bundled Kotlin version has been updated to 1.3.60.
* This release introduces the new DSL API package: __v2019_2__. This package has an updated API for clean-up rules and provides an ability to obtain [DSL context parameters' values](kotlin-dsl.md#contextParameters) inside the Kotlin DSL scripts.

### Updating project report tab definitions in DSL scripts

Parameters of the _ReportTab_ project features should be changed:
* The `revisionRuleRevision` parameter should be removed if the value of the `revisionRuleName` parameter is set to `lastFinished`, `lastSuccessful`, or `lastPinned`.
* The `revisionRuleRevision` parameter should be renamed to `revisionRuleBuildNumber` if the parameter `revisionRuleName` has the `buildNumber` value.
* The `revisionRuleRevision` parameter should be renamed to `revisionRuleBuildTag` and suffix `.tcbuildtag` should be removed from the parameter's value if the parameter `revisionRuleName` has the value `buildTag`.

### DslContext.baseDir

Since TeamCity 2019.2, use the `DslContext.baseDir` property to access a file under the `.teamcity` directory from DSL scripts. For example:
```kotlin
val dataFile = File(DslContext.baseDir, "data/setup.xml")
```

This is required because TeamCity 2019.2 no longer guarantees that the current working directory for DSL scripts is the `.teamcity` directory. 

<anchor name="dsl20191"/>

## Update DSL from 2018.2.x to 2019.1.x

This release introduces the new DSL API version, __v2019_1__, but its package is still `jetbrains.buildServer.configs.kotlin.v2018_2` because there were no significant changes in the DSL between versions 2018.2.x and 2019.1.x.

### Updating Maven build steps

The DSL producing Maven build steps should be updated. If a Maven build step did not have the `useOwnLocalRepo` parameter set to `true`,  the following `localRepoScope` parameter should be added:

```kotlin
maven {
   ...
   localRepoScope = MavenBuildStep.RepositoryScope.MAVEN_DEFAULT
}

```

If `useOwnLocalRepo` was set to `true`, then it should be replaced with:

```kotlin
maven {
   ...
   localRepoScope = MavenBuildStep.RepositoryScope.BUILD_CONFIGURATION
}

```

### Add version to MSBuild and VS.Solution build steps

If MSBuild or VS.Solution build steps have the parameter `toolsVersion` set to `MSBuildStep.MSBuildToolsVersion.V15_0`, the additional `version = MSBuildStep.MSBuildVersion.V15_0` parameter should be added:

```kotlin
msBuild {
    ...
    toolsVersion = MSBuildStep.MSBuildToolsVersion.V15_0
    version = MSBuildStep.MSBuildVersion.V15_0
}
```

### Build configuration parameter buildDefaultBranch is deprecated

The build configuration version control settings parameter `buildDefaultBranch` is deprecated: `branchFilter` should be used instead.   
For instance, if `buildDefaultBranch` was set to `false`, the following branch filter should be specified instead:

```kotlin
vcs {
   branchFilter = """
      +:*
      -:<default>
   """
}
```

<anchor name="dsl20182"/>

## Update DSL from 2018.1.x to 2018.2.x

This release introduces the new DSL API version, __v2018\_2__, its package is `jetbrains.buildServer.configs.kotlin.v2018_2`.

<anchor name="dsl20181"/>

## Update DSL from 2017.2.x to 2018.1.x
[//]: # (AltHead: dsl20181)

This release introduces the new DSL API version, v2018\_1, its package is __jetbrains.buildServer.configs.kotlin.v2018\_1__. The previous API versions work and you can keep using them if you don't want to use portable DSL scripts.

<anchor name="dslConverter850"/>

### Updating Docker parameters
[//]: # (AltHead: dslConverter850)

If you used Kotlin DSL with TeamCity 2017.2 for Docker plugin configurations, you may need to perform some changes in your Kotlin configuration scripts to make your code compatible with TeamCity 2018.1.

The essence of the changes:
* build step __dockerBuild__ is now converted to __dockerCommand__
* the parameters for DockerBuild are now sub\-parameter for commandType selector

Note the difference:

__Docker Build 2 Docker Command migration__

```kotlin
# DockerBuild in 2017.2:
dockerBuild {
    name = "name of the build step"
    source = content {
        content = """
            FROM busybox
             
            MAINTAINER KIR <kir@maxkir.com>
        """.trimIndent()
    }
    namesAndTags = "maxkir/maxkir_test"
}
#----------------------------------------
# DockerBuild in 2018.1:
dockerCommand {
    name = "name of the build step"
    commandType = build {
        source = content {
            content = """
                FROM busybox
                 
                MAINTAINER KIR <kir@maxkir.com>
            """.trimIndent()
        }
        namesAndTags = "maxkir/maxkir_test"
    }
}

```

#### Docker push command support

```kotlin
dockerCommand {
    name = "name of the push step"
    commandType = push {
        namesAndTags = "maxkir/maxkir_test"
    }
}
```

<anchor name="dslConverter839"/>

### Adding label property to Gerrit publisher settings in Commit Status Publisher
[//]: # (AltHead: dslConverter839)

__Since TeamCity 2018.1__ Gerrit publisher settings in the [Commit Status Publisher](commit-status-publisher.md) build feature allow customising the Gerrit label that reflects the build status, i.e. now you can use something other than Verified. 

To manually modify Kotlin DSL settings, the __label = "Verified"__ statement must be added as follows:  


```kotlin
features {
    ...
    commitStatusPublisher {
        publisher = gerrit {
            server = "<server>"
            gerritProject = "<project>"
            failureVote = "-1"
            successVote = "+1"
            userName = "<user>"
            uploadedKey = "<key>"
            label = "Verified"  // the statement to be added
        }
     }
    ...
}
```


<anchor name="dsl20172"/>

## Update DSL from 2017.1.x to 2017.2.x
[//]: # (AltHead: dsl20172)

### DSL version

This release introduces the new DSL API version, `v2017_2`. The previous API version works and you can keep using it if you do not need the [features provided by the new API](https://confluence.jetbrains.com/display/TCD10/What's+New+in+TeamCity+2017.2).

<note>

To get sample DSL code for the newly supported features without switching a project to the Kotlin format, use the __Download settings in Kotlin format__ action on the project administration page.
</note>

If you used 2017.2 EAPs and tested changing DSL settings via the UI, you need to apply all the UI patches created by TeamCity before upgrading as some API is changed in an incompatible way.

The current package name for the settings generated by TeamCity is `jetbrains.buildServer.configs.kotlin.v2017_2`.

With the new API, you can benefit from a number of [new features](https://confluence.jetbrains.com/display/TCD10/What%27s+New+in+TeamCity+2017.2#What'sNewinTeamCity2017.2-KotlinDSLImprovements), including the editable administration UI for Kotlin DSL projects and DSL documentation. To use them for your existing project, your `.kt` files should be switched to packages from the `v2017_2 version`.

* To compile this project, you also need to update your pom.xml. The easiest way is to invoke the __Download settings in Kotlin format__ action in your project and copy the `pom.xml` from the generated zip archive. Alternatively you can update pom.xml yourself with the following:
   * change `teamcity.dsl.version` to: `<teamcity.dsl.version>2017.2</teamcity.dsl.version>`
  * change the kotlin version to: `<kotlin.version>1.1.4-3</kotlin.version>` and add a dependency on kotlin\-runtime and kotlin\-reflect:


```kotlin
<dependency>
  <groupId>org.jetbrains.kotlin</groupId>
  <artifactId>kotlin-runtime</artifactId>
  <version>${kotlin.version}</version>
  <scope>compile</scope>
</dependency>
<dependency>
  <groupId>org.jetbrains.kotlin</groupId>
  <artifactId>kotlin-reflect</artifactId>
  <version>${kotlin.version}</version>
  <scope>compile</scope>
</dependency>

```



Once you switch the project to new API and check in the changes, TeamCity will detect and apply them and after that web UI editing will be enabled.   
To use the new DSL API in a repository with an existing `pom.xml`, the maven dependency version has to be updated to `2017.2`.

### Updating Docker parameters

If you used Kotlin DSL with TeamCity 2017.1 for Docker plugin configurations, you may need to perform some changes in your kotlin configuration scripts to make your code compatible with TeamCity 2017.2. Basically, TeamCity provides a converter for Kotlin configuration scripts to perform those changes automatically, but if it does not work due to some reason, the following changes need to be made manually:
* rename the build runner step with the __Docker Build__ runType to __DockerBuild__
* rename the build runner step with the __Docker Compose__ runType to __DockerCompose__
* rename the `docker-compose.file` build parameter to `dockerCompose.file`

Starting from TeamCity 2017.2, the Docker plugin has its own typed DSL for the [Docker build feature](docker-support.md), [Docker Wrapper](docker-wrapper.md), [Docker](docker.md), and [Docker Compose](docker-compose.md) runners.

__Docker Compose and Docker Build__

```kotlin
steps {
    dockerCompose {
        name = "Start services"
        file = "db-tests/scripts/docker-compose.yml"
    }
 
    dockerBuild {
        name = "Docker build step"
        source = path {
            path = "some/context/Dockerfile"
        }
 
        // Case for Dockerfile specified by an URL:
        //source = url {
        //    url = "https://raw.githubusercontent.com/JetBrains/teamcity-docker-minimal-agent/master/ubuntu/Dockerfile"
        //}
 
        // Case for Dockerfile specified by text:
        //source = content {
        //    content = """
        //        FROM busybox
        //        MAINTAINER Kirill Maximov <kir@jetbrains.com>
        //    """.trimIndent()
        //}
 
        contextDir = "some/context"
        namesAndTags = "my:tag"
    }
}

```

__Docker Build Feature__


```kotlin
features {
    dockerSupport {
        cleanupPushedImages = true
        loginToRegistry = on {
            dockerRegistryId = "PROJECT_EXT_2"
        }
    }
}

```

__Command Line runner with Docker Wrapper__


```kotlin
script {
    scriptContent = "ls -lR"
    dockerImage = "openjdk:8u121"
    dockerPull = true
    dockerRunParameters = "--rm -v /some/path:/another/path:ro"
}

```



 
### Updating default project template

Since 2017.2 EAP3, TeamCity supports default templates in projects. This setting was stored in a project feature of the "DefaultTemplate" type in EAP3 and EAP4, but since 2017.2 RC the project configuration schema was changed to accommodate for default templates.   
To manually convert a DSL project configuration that employs the default template, you will have to delete a corresponding project feature and replace it with the defaultTemplate property assignment as follows:

2017.2 EAP3/4 DSL project configuration with a default template configured:


```kotlin
object Project : Project({
    uuid = "2b241ffb-9019-4e60-9a3a-d5475ab1f312"
    extId = "ExampleProject"
    parentId = "_Root"
    name = "Example Project"
    ...
    features {
        ...
        feature {
            id = "PROJECT_EXT_4"
            type = "DefaultTemplate"
            param("template", "ExampleProject_MyDefaultTemplate")
        }
        ...
    }
    ...
})
```



2017.2 DSL project configuration with the default template configured:


```kotlin
object Project : Project({
    uuid = "2b241ffb-9019-4e60-9a3a-d5475ab1f312"
    extId = "ExampleProject"
    parentId = "_Root"
    name = "Example Project"
    defaultTemplate = "ExampleProject_MyDefaultTemplate"
    ...
    features {
        ...
    }
    ...
})

```


### Updating .NET CLI parameters

__Since 2017.2__ TeamCity bundles .NET CLI plugin. If you were using Kotlin DSL for the plugin parameters in TeamCity 2017.1.x, you need to change the commands as follows. In TeamCity 2017.1.x:


```kotlin
steps {
    step {
        type = "dotnet"
        param("dotnet-command", "build")
        param("dotnet-paths", "WindowsAzure.sln")
    }
}

```



Since TeamCity 2017.2 you could explicitly specify build steps with parameters:


```kotlin
steps {
    dotnetBuild {
        projects = "WindowsAzure.sln"
    }
}

```



#### Common parameters

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-command

</td>

<td>

dotnet&lt;Command&gt;

</td>

<td>

Now the command name reflects the build step name, e.g. `dotnetRestore`

</td></tr><tr>

<td>

dotnet\-args

</td>

<td>

args

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-verbosity

</td>

<td>

logging

</td>

<td>
 

</td></tr></table>

#### dotnet build

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-config

</td>

<td>

configuration

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-framework

</td>

<td>

framework

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-output

</td>

<td>

outputDir

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-runtime

</td>

<td>

runtime

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-no\-deps

</td>

<td>

\-

</td>

<td>

Should be added as the `--no-dependencies` argument

</td></tr><tr>

<td>

dotnet\-build\-not\-incremental

</td>

<td>

\-

</td>

<td>

Should be added as the `--no-incremental` argument

</td></tr></table>

#### dotnet clean

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td></tr><tr>

<td>

dotnet\-clean\-config

</td>

<td>

configuration

</td></tr><tr>

<td>

dotnet\-clean\-framework

</td>

<td>

framework

</td></tr><tr>

<td>

dotnet\-clean\-output

</td>

<td>

outputDir

</td></tr><tr>

<td>

dotnet\-clean\-runtime

</td>

<td>

runtime

</td></tr></table>

#### dotnet msbuild

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td></tr><tr>

<td>

dotnet\-msbuild\-config

</td>

<td>

configuration

</td></tr><tr>

<td>

dotnet\-msbuild\-platform

</td>

<td>

platform

</td></tr><tr>

<td>

dotnet\-msbuild\-targets

</td>

<td>

targets

</td></tr><tr>

<td>

dotnet\-msbuild\-runtime

</td>

<td>

runtime

</td></tr></table>

#### dotnet nuget delete

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-nuget\-delete\-id

</td>

<td>

packageId

</td></tr><tr>

<td>


dotnet\-nuget\-push\-source /

dotnet\-nuget\-delete\-source


</td>

<td>

packageSource

</td></tr><tr>

<td>

secure:dotnet\-nuget\-delete\-api\-key

</td>

<td>

apiKey

</td></tr></table>

#### dotnet nuget push

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

packages

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-nuget\-push\-source

</td>

<td>

packageSource

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-nuget\-push\-no\-symbols

</td>

<td>

noSymbols

</td>

<td>
 

</td></tr><tr>

<td>

secure:dotnet\-nuget\-push\-api\-key

</td>

<td>

outputDir

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-build\-runtime

</td>

<td>

apiKey

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-nuget\-push\-no\-buffer

</td>

<td>

\-

</td>

<td>

Should be added as the `--disable-buffering true` argument

</td></tr></table>

#### dotnet pack

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-config

</td>

<td>

configuration

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-runtime

</td>

<td>

runtime

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-no\-build

</td>

<td>

skipBuild

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-output

</td>

<td>

outputDir

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-version\-suffix

</td>

<td>

versionSuffix

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-pack\-serviceable

</td>

<td>

\-

</td>

<td>

Should be added as the `--serviceable` argument

</td></tr></table>

#### dotnet publish

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td></tr><tr>

<td>

dotnet\-publish\-config

</td>

<td>

configuration

</td></tr><tr>

<td>

dotnet\-publish\-framework

</td>

<td>

framework

</td></tr><tr>

<td>

dotnet\-publish\-output

</td>

<td>

outputDir

</td></tr><tr>

<td>

dotnet\-publish\-runtime

</td>

<td>

runtime

</td></tr><tr>

<td>

dotnet\-publish\-version\-suffix

</td>

<td>

versionSuffix

</td></tr></table>

#### dotnet restore

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-restore\-config

</td>

<td>

configFile

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-restore\-runtime

</td>

<td>

runtime

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-restore\-packages

</td>

<td>

packagesDir

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-restore\-source

</td>

<td>

packageSources

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-restore\-ignore\-failed

</td>

<td>

\-

</td>

<td>

Should be added as the `--ignore-failed-sources` argument

</td></tr><tr>

<td>

dotnet\-restore\-no\-cache

</td>

<td>

\-

</td>

<td>

Should be added as the `--no-cache` argument

</td></tr><tr>

<td>

dotnet\-restore\-parallel

</td>

<td>

\-

</td>

<td>

Should be added as the `--disable-parallel` argument

</td></tr><tr>

<td>

dotnet\-restore\-root\-project

</td>

<td>

\-

</td>

<td>

Should be added as the `--no-dependencies` argument

</td></tr></table>

#### dotnet run

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td></tr><tr>

<td>

dotnet\-run\-config

</td>

<td>

configuration

</td></tr><tr>

<td>

dotnet\-run\-framework

</td>

<td>

framework

</td></tr><tr>

<td>

dotnet\-run\-runtime

</td>

<td>

runtime

</td></tr></table>

#### dotnet test

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

projects

</td></tr><tr>

<td>

dotnet\-test\-config

</td>

<td>

configuration

</td></tr><tr>

<td>

dotnet\-test\-framework

</td>

<td>

framework

</td></tr><tr>

<td>

dotnet\-test\-no\-build

</td>

<td>

skipBuild

</td></tr><tr>

<td>

dotnet\-test\-output

</td>

<td>

outputDir

</td></tr><tr>

<td>

dotnet\-test\-settings\-file

</td>

<td>

settingsFile

</td></tr><tr>

<td>

dotnet\-test\-runtime

</td>

<td>

runtime

</td></tr><tr>

<td>

dotnet\-test\-test\-case\-filter

</td>

<td>

filter

</td></tr></table>

#### dotnet vstest

<table><tr>

<td>

2017.1

</td>

<td>

2017.2

</td>

<td>

Comment

</td></tr><tr>

<td>

dotnet\-paths

</td>

<td>

assemblies

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-vstest\-config\-file

</td>

<td>

settingsFile

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-vstest\-framework

</td>

<td>

framework

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-vstest\-platform

</td>

<td>

platform

</td>

<td>
 

</td></tr><tr>

<td>

dotnet\-vstest\-filter\-type

</td>

<td>

filter

</td>

<td>

To filter tests by name, use `name { names = "..." }`; for the test case filter, use `filter { filter = "..." }`

</td></tr><tr>

<td>

dotnet\-vstest\-is\-isolation

</td>

<td>

\-

</td>

<td>

Should be added as the `/InIsolation` argument

</td></tr></table>

 
<anchor name="dsl20171 "/>

## Update DSL from 10.0.x to 2017.1.x
[//]: # (AltHead: dsl20171 )

TeamCity 2017.1 does not introduce a new Kotlin DSL API, the same package as in TeamCity 10.0.x is used (`jetbrains.buildServer.configs.kotlin.v10`). Several new properties were added to the existing API; to get the latest API for the scripts development, update `teamcity.dsl.version` in `pom.xml` to the `2017.1-SNAPSHOT` for EAP builds and to the `2017.1` for release builds.

### Changes requiring manual Kotlin DSL scripts update

These changes should be performed before enabling versioned settings in the projects where they were disabled on TeamCity upgrade with the message: "Versioned settings are disabled in this project because its settings files were modified during TeamCity upgrade".

#### Converting cloud profiles

This is only relevant if you use Kotlin DSL for the Root project settings and have cloud profiles.   
In 2017.1 cloud profiles were moved from the server level to the Root project level. Since they were not defined in the Kotlin DSL, in case you enable the versioned settings the existing cloud profiles will be deleted form he server. Thus before continuing to use Kotlin DSL for the root project on the server make sure to add the cloud profiles definitions to the root project settings in Kotlin DSL.

To update your settings with the cloud profile information, perform the following:
1. Run the __'Download settings in Kotlin format__' action in the Root project and save the zip with the generated DSL
2. Copy project features of type `CloudIntegration` and `CloudProfile` from the `.teamcity/_Root/Project.kt` file to the root project config in your settings
3. Commit your changes to the VCS
4. Enable versioned settings on the __Versioned Settings__ tab of the Root project.

#### Names in entities

Due to the fix of [issue TW-48609](https://youtrack.jetbrains.com/issue/TW-48609), if your settings contain nameless entities, TeamCity will report corresponding VCS settings errors. You need to manually set a name parameter to such entities to resolve the errors.

### Updating Kotlin DSL configs version to 10.0 to 2017.1

The changes in this section should be done to Kotlin scripts on changing the [scripts config version](#Configs+version) from 10.0 to 2017.1

<anchor name="dslConverter794"/>

#### Updating DotCover parameters
[//]: # (AltHead: dslConverter794)

Parameters used by DotCover were changed and if you use them,  make sure `dotNetCoverage.tool` has the `dotcover` value. If the `dotNetCoverage.dotCover.home.path` parameter is missing, set it to `%teamcity.tool.JetBrains.dotCover.CommandLineTools.bundled%`. The result should look like this:


```kotlin
param("dotNetCoverage.tool", "dotcover")
param("dotNetCoverage.dotCover.home.path", "%teamcity.tool.JetBrains.dotCover.CommandLineTools.bundled%")

```

 

If you use DotCover with custom path (for example, `/custom/path`), then the result should look like this:


```kotlin
param("dotNetCoverage.tool", "dotcover")
param("dotNetCoverage.dotCover.home.path", "/custom/path")

```





#### Updating Maven build step parameters

If you use a typed maven DSL without raw parameters, then this change should not affect you, because typed DSL generates up\-to\-date settings.

If you specify maven build runner settings via the `param("name", "value")` method, then parameters need to be updated. The easiest way to update settings is to switch to the typed DSL: you can generate settings in the Kotlin format to see what the typed DSL for Maven looks like.

If you want to continue using the `param("name", "value")` method, do the following:

* rename the `mavenSelection` parameter to `maven.path`, change its old value to the new one:

<table><tr>

<td>

Old value to be changed


</td>

<td>

New value


</td></tr><tr>

<td>

`mavenSelection:bundledM2`


</td>

<td>

`%teamcity.tool.maven%`


</td></tr><tr>

<td>

`mavenSelection:bundledM3_0`


</td>

<td>

`%teamcity.tool.maven3%`


</td></tr><tr>

<td>

`mavenSelection:bundledM3_1`


</td>

<td>

`%teamcity.tool.maven3_1%`


</td></tr><tr>

<td>

`mavenSelection:bundledM3_2`


</td>

<td>

`%teamcity.tool.maven3_2%`


</td></tr><tr>

<td>

`mavenSelection:bundledM3_3`


</td>

<td>

`%teamcity.tool.maven3_3%`


</td></tr><tr>

<td>

`mavenSelection:default`


</td>

<td>

`%teamcity.tool.maven.AUTO%`


</td></tr><tr>

<td>

`mavenSelection:custom`


</td>

<td>

value of the `maven.home` parameter


</td></tr></table>

 
* remove the `maven.home` parameter.

#### Updating PowerShell build step parameters

TeamCity 2017.1 adds support for cross\-platform PowerShell. Previously PowerShell builds used only the Desktop edition and were run only on Windows.

To ensure that the existing builds remain restricted to the Desktop edition of PowerShell, set the following property in the existing PowerShell steps:


```kotlin
edition = PowerShellStep.Edition.Desktop

```

or if you use raw parameters:


```kotlin
param("jetbrains_powershell_edition", "Desktop")

```

__ __
